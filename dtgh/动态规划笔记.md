# 动态规划笔记

## day1

## 1.动态规划特点

#### 1.计数

有多少种方式从左上角到右下角

有多少种方法选出k个数使和是sum

#### 2.求最大最小值

从左上角到右下角的路径

最长上升子序列

#### 3.求存在性

取石子游戏，先手是否必胜

能不能选出k个数使得和是sum

### 2.动态规划组成部分

#### 1.确定状态

解动态规划题一般需要开一个数组，一维或二维

确定状态需要两个意识

（1）最后一步

（2）子问题

#### 2.转移方程

拼硬币，2，5，7三种硬币拼n元

对任意x，f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}

#### 3.初始条件和边界情况

f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}

俩问题：x-2，x-5，x-7小于0怎么办？

什么时候停下？

不能拼出y，则f[y] = +00

f[1] = min{f[-1]+1, f[-4]+1, f[-6]+1} = +00，表示1品不出来

初始条件：f[0] = 0

#### 4.计数顺序

f[x] = 最少用多少枚硬币拼出x

f[x] = 00表示无法用硬币拼出x

从前往后计算/从后往前计算

### 3.小节

#### 1.确定状态

最后一步（最优策略中使用的最后一枚硬币ak）

化成子问题（最少用多少枚硬币拼出27-ak）

#### 2.转移方程

f[x] = min{f[x-2]+1, f[x-5]+1, f[x-7]+1}

#### 3.初始条件和边界情况

f[0] = 0，若不能拼出y，f[y] = +00

#### 4.计数顺序

f[0],f[1],f[2],...    利用之前的计算结果

## day2

### 坐标型动态规划

不同的路径（62，63）



### 序列型动态规划

房屋染色（515in）

最后一步：最优策略中房子N-1一定染成红，蓝，绿三种颜色一种

相邻不能同色

所以最优策略中房子N是红色，房子N-1只能是蓝色或绿色

所以最优策略中房子N是蓝色，房子N-1只能是红色或绿色

所以最优策略中房子N是绿色，房子N-1只能是红色或蓝色

将第N-1个房子的颜色记下，若和第N个房子颜色相同就返回，让第N-1个房子颜色变色。

子问题：求前N个房子最小花费，即求前N-1个房子是红色，蓝色，绿色的最小花费

初始化：

```c
f[0][0] = f[0][1] = f[0][2] = 0;
```



转移方程：

```c
f[i][0] = min{f[i-1][1]+costs[i-1][0], f[i-1][2] + costs[i-1][0]};
```



#### 小节 

序列型动态规划：...前i个...最小/方式数/可行性

在设计动态规划的过程中，发现需要知道油漆前N栋房子的最优策略中，房子N-1的颜色

如果只用f[N-1],将无法区分颜色

解决方法：记录下房子N-1的颜色（即记录N-1染成三种颜色的最小值）

在房子N-1是红/蓝/绿的情况下，油漆前N栋房子的最小花费



### 划分型动态规划

解密（512）

确定状态：

解密数字串即划分成若干段数字，每段数字对应一个字母

最后一步（最后一段），对应一个字母

A，B，...,或Z

这个字母加密时变成1， 2， ...，或26

子问题：

设数字串长度为N

要求数字串前N个字符的解密方式数

需要知道数字串前N-1和前N-2个字符的解密方式

状态：设数字串前i个数字解密成字母有f[i]种方式

转移方程：

设数字串S前i个数字解密成字符有f[i]种方式

```c
f[i] = f[i-1] | S[i-1]对应一个字母+f[i-2]|S[i-2]S[i-1]对应一个字母
```

初始条件和边界情况：

设数字串S前i个数字解密成字母串有f[i]种方式

初始条件：f[0] = 1，即有1种解密方式

--当N=0时，return 0，不能解密空字符串

边界情况：如果i = 1，只看最后一个数字

计数顺序：

f[0], f[1], ..., f[N]

答案是f[N]

时间复杂度O(N)，空间复杂度O(N)

### 坐标型动态规划

最简单的动态规划类型

给定一个序列或网路

需要找到序列中某个/些子序列或网格中的某条路径

--某种性质最大/最小

--计数

--存在性

动态规划中方程f[i]的下标i表示以ai结尾的满足条件的子序列的性质，fij，中的下标i,j表示以格子(i, j)为结尾满足条件的路径的性质

--最大值/最小值

--个数

--是否存在

### 坐标型动态规划总结

给定输入为序列或者网格/矩阵

动态规划状态下标为序列下标i或者网格坐标(i, j)

```c
--f[i]:以第i个元素结尾的某种性质
```

```c
--f[i][j]:到格子(i, j)的路径的性质`
```

```c
初始化设置f[0]的值/f[0][0...n-1]的值
```

```c
二维空间优化：如果f[i][j]的值只依赖于当前行和前一行，则可以用滚动数组节省空间
```

## 序列+位操作动态规划

位操作（二进制）

&  |  ^  !

逐位操作

数1(664in)

确定状态：

(170) = (10101010)

(85) = (101010101)

85和170有相同1

子问题：

求N有多少个1

在N的二进制中去掉最后一位Nmod2，设新书为Y=(x>>1)

要知道Y的二进制有多少个1

状态：f[i]表示i的二进制中有多少个1

转移方程：f[i] = f[i>>1] + imod2

初始条件：f[0] = 0

计数顺序

f[0], f[1], f[2], ..., f[N]

时间复杂度O(N)

空间复杂度O(N)

## day3

### 序列型动态规划

给定一个序列

f[i]中的下标i表示前i个元素的a[0], a[1], ... a[i]的某种性质

--坐标型的f[i]表示以ai为结尾的某种性质

初始化中，f[0]表示空序列的性质

--坐标型动态规划的初始条件f[0]就是指以a0结尾的子序列的性质
