/*
某校大门外长度为 l 的马路上有一排树，每两棵相邻的树之间的间隔都是 1 米。
我们可以把马路看成一个数轴，马路的一端在数轴 000 的位置，另一端在 lll 的位置；
数轴上的每个整数点，即 0,1,2,…,l0,1,2,\dots,l0,1,2,…,l，都种有一棵树。

由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。
已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。
现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，
马路上还有多少棵树。

输入格式

第一行有两个整数，分别表示马路的长度 l 和区域的数目 m。

接下来 m 行，每行两个整数 u,v,u,v,u,v，表示一个区域的起始点和终止点的坐标。
输出格式

输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。

输入
500 3
150 300
100 200
470 471

输出
298
*/

# include <stdio.h>
# include <stdlib.h>
# include <malloc.h>

int main(void)
{
    int val, i, j, k, sum = 0;

    scanf("%d %d", &val, &k);

    int *arr1 = (int *)malloc(sizeof(int) * (val + 1));
    int arr2[500][2] = {0};

    for (i = 0; i < k; ++i)
    {
        scanf("%d %d", &arr2[i][0], &arr2[i][1]);
    }
    for (i = 0; i <= val; ++i)
    {
        arr1[i] = 1;
    }

    for (i = 0; i < k; ++i)
    {
        for (j = arr2[i][0]; j <= arr2[i][1]; ++j)
        {
            arr1[j] = 0;
        }
    }

    for (i = 0; i <= val; ++i)
    {
        if (arr1[i] == 1)
        {
            sum += 1;
        }
    }
    printf("%d", sum);

    return 0;
}