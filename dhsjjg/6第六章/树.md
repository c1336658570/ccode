## 树

### 树的存储结构

#### 双亲表示法

```c
/* 树的双亲表示法结点结构定义 */
#define MAX_TREE_SIZE 100
/* 树结点的数据类型，目前暂定为整型 */
typedef int TElemType;              
/* 结点结构 */
typedef struct PTNode               
{
    /* 结点数据 */
    TElemType data;                 
    /* 双亲位置 */
    int parent;                     
} PTNode;
/* 树结构 */
typedef struct                      
{
    /* 结点数组 */
    PTNode nodes[MAX_TREE_SIZE];    
    /* 根的位置和结点数 */
    int r, n;                       
} PTree;
```

data是数据域，parent是指针域，存储该结点的双亲在数组中的下标。根结点是没有双亲的，所以我们约定根结点的位置域设置为-1

| 下标 | data | parent |
| ---- | ---- | ------ |
| 0    | A    | -1     |
| 1    | B    | 0      |
| 2    | C    | 0      |
| 3    | D    | 1      |
| 4    | E    | 2      |
| 5    | F    | 2      |
| 6    | G    | 3      |
| 7    | H    | 3      |
| 8    | I    | 3      |
| 9    | J    | 4      |

我们可以根据结点的parent指针很容易找到它的双亲结点，所用的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。

我们增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1。

| 下标 | data | parent | firstchild |
| ---- | ---- | ------ | ---------- |
| 0    | A    | -1     | 1          |
| 1    | B    | 0      | 3          |
| 2    | C    | 0      | 4          |
| 3    | D    | 1      | 6          |
| 4    | E    | 2      | 9          |
| 5    | F    | 2      | -1         |
| 6    | G    | 3      | -1         |
| 7    | H    | 3      | -1         |
| 8    | I    | 3      | -1         |
| 9    | J    | 4      | -1         |

对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。

另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，那我们怎么办？嗯，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1。

| 下标 | data | parent | rightsib |
| ---- | ---- | ------ | -------- |
| 0    | A    | -1     | -1       |
| 1    | B    | 0      | 2        |
| 2    | C    | 0      | -1       |
| 3    | D    | 1      | -1       |
| 4    | E    | 2      | 5        |
| 5    | F    | 2      | -1       |
| 6    | G    | 3      | 7        |
| 7    | H    | 3      | 8        |
| 8    | I    | 3      | -1       |
| 9    | J    | 4      | -1       |

但如果结点的孩子很多，超过了2个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。

#### **孩子表示法**

由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。

方案一

一种是指针域的个数就等于树的度。

| data | child1 | child2 | child3 | ........ | childd |
| ---- | ------ | ------ | ------ | -------- | ------ |

data是数据域。child1到childd是指针域，用来指向该结点的孩子结点。

这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。既然很多指针域都可能为空，为什么不按需分配空间呢。

方案二

第二种方案每个结点指针域的个数等于该结点的度，我们专门取一个位置来存储结点指针域的个数。

| data | degree | child1 | child2 | ...... | childd |
| ---- | ------ | ------ | ------ | ------ | ------ |

data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到childd为指针域，指向该结点的各个孩子的结点。

这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。能否有更好的方法，既可以减少空指针的浪费又能使结点结构相同。仔细观察，我们为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。这就是我们要讲的孩子表示法。把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

设计两种结点结构，一个是孩子链表的孩子结点

| child | next |
| ----- | ---- |

其中child是数据域，用来存储某个结点在表头数组中的下标。next是指针域，用来存储指向某结点的下一个孩子结点的指针。

另一个是表头数组的表头结点

| data | firstchild |
| ---- | ---------- |

data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点的孩子链表的头指针。

```c
/* 树的孩子表示法结构定义 */
#define MAX_TREE_SIZE 100
/* 孩子结点 */
typedef struct CTNode              
{
    int child;
    struct CTNode *next;
} *ChildPtr;
/* 表头结构 */
typedef struct                     
{
    TElemType data;
    ChildPtr firstchild;
} CTBox;
/* 树结构 */
typedef struct                     
{
    /* 结点数组 */
    CTBox nodes[MAX_TREE_SIZE];    
    /* 根的位置和结点数 */
    int r,n;                       
} CTree;
```

这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。

但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行，难道就不可以把双亲表示法和孩子表示法综合一下吗？当然是可以。

只需要修改表头数组的表头结点

| data | parent | firstchild |
| ---- | ------ | ---------- |

我们把这种方法称为双亲孩子表示法，应该算是孩子表示法的改进。

#### **孩子兄弟表示法**

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

| data | firstchild | rightsib |
| ---- | ---------- | -------- |

data是数据域，firstchild为指针域，存储该结点的第一个孩子结点的存储地址，right-sib是指针域，存储该结点的右兄弟结点的存储地址。

```c
/* 树的孩子兄弟表示法结构定义 */
typedef struct CSNode
{
    TElemType data;
    struct CSNode *firstchild, 
                  *rightsib;
} CSNode, *CSTree;
```

给查找某个结点的某个孩子带来了方便，只需要通过fistchild找到此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子。当然，如果想找某个结点的双亲，这个表示法也是有缺陷的。如果真的有必要，完全可以再增加一个parent指针域来解决快速查找双亲的问题。

**其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。**

### **二叉树的定义**

#### **二叉树特点**

- 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。

- 左子树和右子树是有顺序的，次序不能任意颠倒。就像人有双手、双脚，但显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会极其别扭和难受。
- 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

二叉树具有五种基本形态： 1.空二叉树。 2.只有一个根结点。 3.根结点只有左子树。 4.根结点只有右子树。 5.根结点既有左子树又有右子树。

#### 特殊二叉树

1．斜树

顾名思义，斜树一定要是斜的，但是往哪斜还是有讲究。所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。斜树有很明显的特点，就是每一层都只有一个结点，结点的个数与二叉树的深度相同。有人会想，这也能叫树呀，与我们的线性表结构不是一样吗。对的，其实线性表结构就可以理解为是树的一种极其特殊的表现形式。

2．满二叉树

如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

单是每个结点都存在左右子树，不能算是满二叉树，还必须要所有的叶子都在同一层上，这就做到了整棵树的平衡。因此，满二叉树的特点有：（1）叶子只能出现在最下一层。（2）非叶子结点的度一定是2。（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

3．完全二叉树

如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

首先从字面上要区分，“完全”和“满”的差异，满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。

完全二叉树的特点：（1）叶子结点只能出现在最下两层。（2）最下层的叶子一定集中在左部连续位置。（3）倒数二层，若有叶子结点，一定都在右部连续位置。（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。（5）同样结点数的二叉树，完全二叉树的深度最小。

**若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。**

#### **二叉树的性质**

##### **二叉树性质1**

在二叉树的第i层上至多有2的i-1次方个结点（i≥1）。

##### **二叉树性质2**

深度为k的二叉树至多有2的k次方-1个结点（k≥1）。

##### 二叉树性质3

对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

n = n0 + n1 + n2

n = n2 * 2 + n1 + 1（n2*2和n1为分支数）总结点数等与总分支数+1。

##### **二叉树性质4**

具有n个结点的完全二叉树的深度为|log2n+1|（|x|表示不大于x的最大整数）。

深度为k的满二叉树的结点数n一定是2的k次方-1。那么对于n=2的k次方-1倒推得到满二叉树的深度为k=log2(n＋1)。完全二叉树我们前面已经提到，它是一棵具有n个结点的二叉树，若按层序编号后其编号与同样深度的满二叉树中编号结点在二叉树中位置完全相同，那它就是完全二叉树。也就是说，它的叶子结点只会出现在最下面的两层。它的结点数一定少于等于同样深度的满二叉树的结点数2的k次方-1，但一定多于2的k-1次方-1。即满足2的k-1次方-1<n≤2的k次方-1。由于结点数n是整数，n≤2的k次方-1意味着n<2k次方，n>2的k-1次方-1，意味着n≥2的k次方-1，所以2的k-1此法哪个≤n<2的k次方，不等式两边取对数，得到k-1≤log2n<k，而k作为深度也是整数，因此k=|log2n|+1。

##### **二叉树性质5**

如果对一棵有n个结点的完全二叉树（其深度为）的结点按层序编号（从第1层到第层，每层从左到右），对任一结点i（1≤i≤n）有：

1．如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点。

2．如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。

3．如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1。