## 图

### **图的定义**

图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

- 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点（Vertex）。
- 线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有顶点。在定义中，若V是顶点的集合，则强调了顶点集合V有穷非空。
- 线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。

#### **各种图定义**

无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边（Edge），用无序偶对(vi,vj)来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）。

有向边：若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧（Arc）。用有序偶<vi,vj>来表示，vi称为弧尾（Tail），vj称为弧头（Head）。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）。

无向边用小括号“()”表示，而有向边则是用尖括号“<>”表示。

在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。

在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图,含有n个顶点的无向完全图有n×(n-1)/2

在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有n×(n-1)条边

对于具有n个顶点和e条边数的图，无向图0≤e≤n(n-1)/2，有向图0≤e≤n(n-1)。

有很少条边或弧的图称为稀疏图，反之称为稠密图。

有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight）。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网。

假设有两个图G=(V,{E})和G'=(V',{E'})，如果V'属于V且E属于'E，则称G'为G的子图

#### **图的顶点与边间关系**

对于无向图G=(V,{E})，如果边(v,v')∈E，则称顶点v和v'互为邻接点（Adjacent），即v和v'相邻接。边(v,v')依附（incident）于顶点v和v'，或者说(v,v')与顶点v和v'相关联。顶点v的度（Degree）是和v相关联的边的数目，记为TD(v)。边数其实就是各顶点度数和的一半，多出的一半是因为重复两次记数。

对于有向图G=(V,{E})，如果弧<v,v'>∈E，则称顶点v邻接到顶点v'，顶点v'邻接自顶点v。弧<v,v'>和顶点v，v'相关联。以顶点v为头的弧的数目称为v的入度（InDegree），记为ID(v)；以v为尾的弧的数目称为v的出度（OutDegree），记为OD(v);顶点v的度为TD(v)=ID(v)+OD(v)。e = ID = OD

无向图G=(V,{E})中从顶点v到顶点v'的路径（Path）是一个顶点序列(v=vi,0,vi,1,...,vi,m=v')，其中(vi,j-1,vi,j)∈E，1≤j≤m。如果G是有向图，则路径也是有向的，顶点序列应满足<vi,j-1,vi,j>∈E，1≤j≤m。

树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。路径的长度是路径上的边或弧的数目。

第一个顶点和最后一个顶点相同的路径称为回路或环（Cycle）。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

#### **连通图相关术语**

在无向图G中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对于图中任意两个顶点vi、vj∈V，vi和vj都是连通的，则称G是连通图（Connected Graph）。

无向图中的极大连通子图称为连通分量。注意连通分量的概念，它强调：

- 要是子图；
- 子图要是连通的；
- 连通子图含有极大顶点数；
- 具有极大顶点数的连通子图包含依附于这些顶点的所有边。

在有向图G中，如果对于每一对vi、vj∈V、vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。

现在我们再来看连通图的生成树定义。所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1边条，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。有n-1条边并不一定是生成树。

如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一个有向树。对有向树的理解比较容易，所谓入度为0其实就相当于树中的根结点，其余顶点入度为1就是说树的非根结点的双亲只有一个。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

#### **图的定义与术语总结**

图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和弧构成。弧有弧尾和弧头之分。

图按照边或弧的多少分稀疏图和稠密图。如果任意两个顶点之间都存在边叫完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。

图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。

图上的边或弧上带权则称为网。

图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图，有向则称强连通图。图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。

无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。

### **图的抽象数据类型**

```c
ADT 图(Graph)
Data
    顶点的有穷非空集合和边的集合。
Operation
    CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。
    DestroyGraph(*G):       图G存在则销毁。
    LocateVex(G, u):        若图G中存在顶点u，则返回图中的位置。
    GetVex(G, v):           返回图G中顶点v的值。
    PutVex(G, v, value):    将图G中顶点v赋值value。
    FirstAdjVex(G, *v):     返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。
    NextAdjVex(G, v, *w):   返回顶点v相对于顶点w的下一个邻接顶点，
                            若w是v的最后一个邻接点则返回“空”。
    InsertVex(*G, v):       在图G中增添新顶点v。
    DeleteVex(*G, v):       删除图G中顶点v及其相关的弧。
    InsertArc(*G, v, w):    在图G中增添弧<v,w>，若G是无向图，还需要增添对称弧<w,v>。
    DeleteArc(*G, v, w):    在图G中删除弧<v,w>，若G是无向图，则还删除对称弧<w,v>。
    DFSTraverse(G):         对图G中进行深度优先遍历，在遍历过程对每个顶点调用。
    HFSTraverse(G):         对图G中进行广度优先遍历，在遍历过程对每个顶点调用。
endADT
```

### **图的存储结构**

#### **邻接矩阵**

考虑到图是由顶点和边或弧两部分组成。合在一起比较困难，那就很自然地考虑到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。于是我们的邻接矩阵的方案就诞生了。

图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。

设图G有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：

> a[i] [j] = 1,(vi, vj) ∈E或<vi, vj>∈E
>
> a[i] [j] = 0, 反之

对于矩阵的主对角线的值，即arc[0] [0]、arc[1] [1]、arc[2] [2]、arc[3] [3]，全为0是因为不存在顶点到自身的边，比如v0到v0。arc[0] [1]=1是因为v0到v1的边存在，而arc[1] [3]=0是因为v1到v3的边不存在。并且由于是无向图，v1到v3的边不存在，意味着v3到v1的边也不存在。所以无向图的边数组是一个对称矩阵。

有了这个矩阵，我们就可以很容易地知道图中的信息。
1.我们要判定任意两顶点是否有边无边就非常容易了。
2.我们要知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行（或第i列）的元素之和。
3.求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i] [j]为1就是邻接点。

顶点数组为vertex[4]={v0,v1,v2,v3}，弧数组arc[4] [4]为图7-4-3右图这样的一个矩阵。主对角线上数值依然为0。但因为是有向图，所以此矩阵并不对称，比如由v1到v0有弧，得到arc[1] [0]=1，而v0到v1没有弧，因此arc[0] [1]=0。

有向图讲究入度与出度，顶点v1的入度为1，正好是第v1列各数之和。顶点v1的出度为2，即第v1行的各数之和。

与无向图同样的办法，判断顶点vi到vj是否存在弧，只需要查找矩阵中arc[i] [j]是否为1即可。要求vi的所有邻接点就是将矩阵第i行元素扫描一遍，查找arc[i] [j]为1的顶点。

在图的术语中，我们提到了网的概念，也就是每条边上带有权的图叫做网。那么这些权值就需要存下来，如何处理这个矩阵来适应这个需求呢？我们有办法。

设图G是网图，有n个顶点，则邻接矩阵是一个n×n的方阵，定义为：

这里wij表示（vi,vj）或<vi,vj>上的权值。∞表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。有同学会问，为什么不是0呢？原因在于权值wij大多数情况下是正值，但个别时候可能就是0，甚至有可能是负值。因此必须要用一个不可能的值来代表不存在。

```c
// 邻接矩阵存储的结构
/* 顶点类型应由用户定义 */
typedef char VertexType;             
/* 边上的权值类型应由用户定义 */
typedef int EdgeType;                
/* 最大顶点数，应由用户定义 */
#define MAXVEX 100                   
/* 用65535来代表∞ */
#define INFINITY 65535               
typedef struct
{
    /* 顶点表 */
    VertexType vexs[MAXVEX];         
    /* 邻接矩阵，可看作边表 */
    EdgeType arc[MAXVEX][MAXVEX];    
    /* 图中当前的顶点数和边数 */
    int numVertexes, numEdges;       
} MGraph;
```

```c

// 无向网图的创建
/* 建立无向网图的邻接矩阵表示 */
void CreateMGraph(MGraph *G)
{
    int i, j, k, w;
    printf("输入顶点数和边数:\n");
    /* 输入顶点数和边数 */
    scanf("%d,%d", &G->numVertexes, &G->numEdges);    
    /* 读入顶点信息，建立顶点表 */
    for (i = 0; i < G->numVertexes; i++)              
        scanf(&G->vexs[i]);
    for (i = 0; i < G->numVertexes; i++)
        for (j = 0; j <G->numVertexes; j++)
            /* 邻接矩阵初始化 */
            G->arc[i][j] = INFINITY;                  
    /* 读入numEdges条边，建立邻接矩阵 */
    for (k = 0; k < G->numEdges; k++)                 
    {
        printf("输入边(vi,vj)上的下标i，下标j和权w:\n");
        /* 输入边(vi,vj)上的权w */
        scanf("%d,%d,%d", &i, &j, &w);                
        G->arc[i][j] = w;
        /* 因为是无向图，矩阵对称 */
        G->arc[j][i] = G->arc[i][j];                  
    }
}

```

n个顶点和e条边的无向网图的创建，时间复杂度为O(n+n的2次方+e)，其中对邻接矩阵G.arc的初始化耗费了O(n的2次方)的时间。

#### **邻接表**

邻接矩阵是不错的一种图存储结构，但是我们也发现，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。回忆我们在线性表时谈到，顺序存储结构就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。再回忆我们在树中谈存储结构时，讲到了一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间浪费问题。这个思路同样适用于图的存储。我们把这种数组与链表相结合的存储方法称为邻接表（Ad-jacency List）。

邻接表的处理办法是这样。

1.图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。
2.图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。

顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。这样的结构，对于我们要获得图的相关信息也是很方便的。比如我们要想知道某个顶点的度，就去查找这个顶点的边表中结点的个数。若要判断顶点vi到vj是否存在边，只需要测试顶点vi的边表中adjvex是否存在结点vj的下标j就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到的adjvex域对应的顶点就是邻接点。

若是有向图，邻接表结构是类似的，但要注意的是有向图由于有方向，我们是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点vi都建立一个链接为vi为弧头的表。对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。

```c
// 结点定义
/* 顶点类型应由用户定义 */
typedef char VertexType;          
/* 边上的权值类型应由用户定义 */
typedef int EdgeType;             
/* 边表结点 */
typedef struct EdgeNode           
{
    /* 邻接点域，存储该顶点对应的下标 */
    int adjvex;                   
    /* 用于存储权值，对于非网图可以不需要 */
    EdgeType weight;              
    /* 链域，指向下一个邻接点　 */
    struct EdgeNode *next;        
} EdgeNode;
/* 顶点表结点 */
typedef struct VertexNode         
{
    /* 顶点域，存储顶点信息 */
    VertexType data;              
    /* 边表头指针 */
    EdgeNode *firstedge;          
} VertexNode, AdjList[MAXVEX];
typedef struct
{
    AdjList adjList;
    /* 图中当前顶点数和边数 */
    int numVertexes, numEdges;    
} GraphAdjList;
```

```c
// 邻接表创建
/* 建立图的邻接表结构 */
void  CreateALGraph(GraphAdjList *G)
{
    int i, j, k;
    EdgeNode *e;
    printf("输入顶点数和边数:\n");
    /* 输入顶点数和边数 */
    scanf("%d,%d", &G->numVertexes, 
          &G->numEdges);    
    /* 读入顶点信息，建立顶点表 */
    for (i = 0; i < G->numVertexes; i++)              
    {
        /* 输入顶点信息 */
        scanf(&G->adjList[i].data);                   
        /* 将边表置为空表 */
        G->adjList[i].firstedge = NULL;               
    }
    /* 建立边表 */
    for (k = 0; k < G->numEdges; k++)                 
    {
        printf("输入边(vi,vj)上的顶点序号:\n");
        /* 输入边(vi,vj)上的顶点序号 */
        scanf("%d,%d", &i, &j);                       
        /* 向内存申请空间， */
        /* 生成边表结点 */
        e = (EdgeNode *)malloc(sizeof(EdgeNode));     
        /* 邻接序号为j */
        e->adjvex = j;                                
        /* 将e指针指向当前顶点指向的结点 */
        e->next = G->adjList[i].firstedge;            
        /* 将当前顶点的指针指向e */
        G->adjList[i].firstedge = e;                  
        /* 向内存申请空间， */
        /* 生成边表结点 */
        e = (EdgeNode *)malloc(sizeof(EdgeNode));     
        /* 邻接序号为i */
        e->adjvex = i;                                
        /* 将e指针指向当前顶点指向的结点 */
        e->next = G->adjList[j].firstedge;            
        /* 将当前顶点的指针指向e */
        G->adjList[j].firstedge = e;                  
    }
}
```

本算法的时间复杂度，对于n个顶点e条边来说，很容易得出是O(n+e)。

#### **十字链表**

那么对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。有没有可能把邻接表与逆邻接表结合起来呢？答案是肯定的，就是把它们整合在一起。这就是我们现在要讲的有向图的一种存储方法：十字链表（Orthogonal List）。

| data | firstin | firstout |
| ---- | ------- | -------- |

其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表示出边表头指针，指向该顶点的出边表中的第一个结点。

| tailvex | headvex | headlink | taillink |
| ------- | ------- | -------- | -------- |

其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。

其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。

十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以vi为尾的弧，也容易找到以vi为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。

#### **邻接多重表**

讲了有向图的优化存储结构，对于无向图的邻接表，有没有问题呢？如果我们在无向图的应用中，关注的重点是顶点，那么邻接表是不错的选择，但如果我们更关注边的操作，比如对已访问过的边做标记，删除某一条边等操作，那就意味着，需要找到这条边的两个边表结点进行操作，这其实还是比较麻烦的。

因此，我们也仿照十字链表的方式，对边表结点的结构进行一些改造，也许就可以避免刚才提到的问题。

重新定义的边表结点结构

| ivex | ilink | jvex | jlink |
| ---- | ----- | ---- | ----- |

其中ivex和jvex是与某条边依附的两个顶点在顶点表中的下标。ilink指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边。这就是邻接多重表结构。

我们来看结构示意图的绘制过程，理解了它是如何连线的，也就理解邻接多重表构造原理了。如图7-4-12所示，左图告诉我们它有4个顶点和5条边，显然，我们就应该先将4个顶点和5条边的边表结点画出来。由于是无向图，所以ivex是0、jvex是1还是反过来都是无所谓的，不过为了绘图方便，都将ivex值设置得与一旁的顶点下标相同。我们开始连线，如图7-4-13。首先连线的①②③④就是将顶点的firstedge指向一条边，顶点下标要与ivex的值相同，这很好理解。接着，由于顶点v0的(v0,v1)边的邻边有(v0,v3)和(v0,v2)。因此⑤⑥的连线就是满足指向下一条依附于顶点v0的边的目标，注意ilink指向的结点的jvex一定要和它本身的ivex的值相同。同样的道理，连线⑦就是指(v1,v0)这条边，它是相当于顶点v1指向(v1,v2)边后的下一条。v2有三条边依附，所以在③之后就有了⑧⑨。连线⑩的就是顶点v3在连线④之后的下一条边。左图一共有5条边，所以右图有10条连线，完全符合预期。邻接多重表与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。

![2022-08-03 16-03-48屏幕截图](/home/cccmmf/ccode/dhsjjg/screenshot/2022-08-03 16-03-48屏幕截图.png)

####  **边集数组**

边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成。。显然边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。

| begin | end  | weight |
| ----- | ---- | ------ |

其中begin是存储起点下标，end是存储终点下标，weight是存储权值。



### **图的遍历**

图的遍历是和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历（Traversing Graph）。

树的遍历我们谈到了四种方案，应该说都还好，毕竟根结点只有一个，遍历都是从它发起，其余所有结点都只有一个双亲。可图就复杂多了，因为它的任一顶点都可能和其余的所有顶点相邻接，极有可能存在沿着某条路径搜索后，又回到原顶点，而有些顶点却还没有遍历到的情况。因此我们需要在遍历过程中把访问过的顶点打上标记，以避免访问多次而不自知。具体办法是设置一个访问数组visited[n]，n是图中顶点的个数，初值为0，访问过后设置为1。这其实在小说中常常见到，一行人在迷宫中迷了路，为了避免找寻出路时屡次重复，所以会在路口用小刀刻上标记。

对于图的遍历来说，如何避免因回路陷入死循环，就需要科学地设计遍历方案，通常有两种遍历次序方案：它们是深度优先遍历和广度优先遍历。

#### **深度优先遍历**

深度优先遍历（Depth_First_Search），也有称为深度优先搜索，简称为DFS。它的具体思想就如同我刚才提到的找钥匙方案，无论从哪一间房间开始都可以，比如主卧室，然后从房间的一个角开始，将房间内的墙角、床头柜、床上、床下、衣柜里、衣柜上、前面的电视柜等挨个寻找，做到不放过任何一个死角，所有的抽屉、储藏柜中全部都找遍，形象比喻就是翻个底朝天，然后再寻找下一间，直到找到为止。

![2022-08-03 20-27-47屏幕截图](/home/cccmmf/ccode/dhsjjg/screenshot/2022-08-03 20-27-47屏幕截图.png)首先我们从顶点A开始，做上表示走过的记号后，面前有两条路，通向B和F，我们给自己定一个原则，在没有碰到重复顶点的情况下，始终是向右手边走，于是走到了B顶点。整个行路过程，可参看图7-5-2的右图。此时发现有三条分支，分别通向顶点C、I、G，右手通行原则，使得我们走到了C顶点。就这样，我们一直顺着右手通道走，一直走到F顶点。当我们依然选择右手通道走过去后，发现走回到顶点A了，因为在这里做了记号表示已经走过。此时我们退回到顶点F，走向从右数的第二条通道，到了G顶点，它有三条通道，发现B和D都已经是走过的，于是走到H，当我们面对通向H的两条通道D和E时，会发现都已经走过了。

此时我们是否已经遍历了所有顶点呢？没有。可能还有很多分支的顶点我们没有走到，所以我们按原路返回。在顶点H处，再无通道没走过，返回到G，也无未走过通道，返回到F，没有通道，返回到E，有一条通道通往H的通道，验证后也是走过的，再返回到顶点D，此时还有三条道未走过，一条条来，H走过了，G走过了，I，哦，这是一个新顶点，没有标记，赶快记下来。继续返回，直到返回顶点A，确认你已经完成遍历任务，找到了所有的9个顶点。

深度优先遍历其实就是一个递归的过程，如果再敏感一些，会发现其实转换成如图7-5-2的右图后，就像是一棵树的前序遍历，没错，它就是。它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。事实上，我们这里讲到的是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

```c
// 邻接矩阵DFS
/* Boolean是布尔类型，其值是TRUE或FALSE */
typedef int Boolean;             
/* 访问标志的数组 */
Boolean visited[MAX];            
/* 邻接矩阵的深度优先递归算法 */
void DFS(MGraph G, int i)
{
    int j;
    visited[i] = TRUE;
    /* 打印顶点，也可以其他操作 */
    printf("%c ", G.vexs[i]);    
    for (j = 0; j < G.numVertexes; j++)
        if (G.arc[i][j] == 1 && !visited[j])
            /* 对为访问的邻接顶点递归调用 */
            DFS(G, j);           
}
/* 邻接矩阵的深度遍历操作 */
void DFSTraverse(MGraph G)
{
    int i;
    for (i = 0; i < G.numVertexes; i++)
        /* 初始所有顶点状态都是未访问过状态 */
        visited[i] = FALSE;      
    for (i = 0; i < G.numVertexes; i++)
        /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */
        if (!visited[i])         
            DFS(G, i);
}

```

```c
// 邻接表DFS
/* 邻接表的深度优先递归算法 */
void DFS(GraphAdjList GL, int i)
{
    EdgeNode *p;
    visited[i] = TRUE;
    /* 打印顶点，也可以其他操作 */
    printf("%c ", GL->adjList[i].data);    
    p = GL->adjList[i].firstedge;
    while (p)
    {
        if (!visited[p->adjvex])
            /* 对为访问的邻接顶点递归调用 */
            DFS(GL, p->adjvex);            
        p = p->next;
    }
}
/* 邻接表的深度遍历操作 */
void DFSTraverse(GraphAdjList GL)
{
    int i;
    for (i = 0; i < GL->numVertexes; i++)
        /* 初始所有顶点状态都是未访问过状态 */
        visited[i] = FALSE;                
    for (i = 0; i < GL->numVertexes; i++)
        /* 对未访问过的顶点调用DFS，若是连通图，只会执行一次 */
        if (!visited[i])                   
            DFS(GL, i);
}
```

对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要O(n的2次方)的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是O(n+e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。

#### **广度优先遍历**

广度优先遍历（Breadth_First_Search），又称为广度优先搜索，简称BFS。还是以找钥匙的例子为例。小孩子不太可能把钥匙丢到大衣柜顶上或厨房的油烟机里去，深度优先遍历意味着要彻底查找完一个房间才查找下一个房间，这未必是最佳方案。所以不妨先把家里的所有房间简单看一遍，看看钥匙是不是就放在很显眼的位置，如果全走一遍没有，再把小孩在每个房间玩得最多的地方或各个家俱的下面找一找，如果还是没有，那看一下每个房间的抽屉，这样一步步扩大查找的范围，直到找到为止。事实上，我在全屋查找的第二遍时就在抽水马桶后面的地板上找到了。

如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。我们将图7-5-3的第一幅图稍微变形，变形原则是顶点A放置在最上第一层，让与它有边的顶点B、F为第二层，再让与B和F有边的顶点C、I、G、E为第三层，再将这四个顶点有边的D、H放在第四层，如图7-5-3的第二幅图所示。此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系还是完全相同的。

![2022-08-03 20-37-43屏幕截图](/home/cccmmf/ccode/dhsjjg/screenshot/2022-08-03 20-37-43屏幕截图.png)

邻接矩阵结构的广度优先遍历算法。

```c
/* 邻接矩阵的广度遍历算法 */
void BFSTraverse(MGraph G)
{
    int i, j;
    Queue Q;
    for (i = 0; i < G.numVertexes; i++)
        visited[i] = FALSE;
    /* 初始化一辅助用的队列 */
    InitQueue(&Q);                                   
    /* 对每一个顶点做循环 */
    for (i = 0; i < G.numVertexes; i++)              
    {
        /* 若是未访问过就处理 */
        if (!visited[i])                             
        {
            /* 设置当前顶点访问过 */
            visited[i]=TRUE;                         
            /* 打印顶点，也可以其他操作 */
            printf("%c ", G.vexs[i]);                
            /* 将此顶点入队列 */
            EnQueue(&Q,i);                           
            /* 若当前队列不为空 */
            while (!QueueEmpty(Q))                   
            {
                /* 将队中元素出队列，赋值给i */
                DeQueue(&Q, &i);                     
                for (j = 0; j < G.numVertexes; j++)
                {
                    /* 判断其他顶点若与当前顶点存在边且未访问过 */
                    if (G.arc[i][j] == 1 && !visited[j])
                    {
                        /* 将找到的此顶点标记为已访问 */
                        visited[j]=TRUE;             
                        /* 打印顶点 */
                        printf("%c ", G.vexs[j]);    
                        /* 将找到的此顶点入队列 */
                        EnQueue(&Q,j);               
                    }
                }
            }
        }
    }
}
```

邻接表的广度优先遍历

```c
/* 邻接表的广度遍历算法 */
void BFSTraverse(GraphAdjList GL)
{
    int i;
    EdgeNode *p;
    Queue Q;
    for (i = 0; i < GL->numVertexes; i++)
        visited[i] = FALSE;
    InitQueue(&Q);
    for (i = 0; i < GL->numVertexes; i++)
    {
        if (!visited[i])
        {
            visited[i] = TRUE;
            /* 打印顶点，也可以其他操作 */
            printf("%c ", GL->adjList[i].data);    
            EnQueue(&Q, i);
            while (!QueueEmpty(Q))
            {
                DeQueue(&Q, &i);
                /* 找到当前顶点边表链表头指针 */
                p = GL->adjList[i].firstedge;      
                while (p)
                {
                    /* 若此顶点未被访问 */
                    if (!visited[p->adjvex])       
                    {
                        visited[p->adjvex] = TRUE;
                        printf("%c ", GL->adjList[p->adjvex].data);
                        /* 将此顶点入队列 */
                        EnQueue(&Q, p->adjvex);    
                    }
                    /* 指针指向下一个邻接点 */
                    p = p->next;                   
                }
            }
        }
    }
}
```



对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。

这里还要再多说几句，对于深度和广度而言，已经不是简单的算法实现问题，完全可以上升到方法论的角度。你求学是博览群书、不求甚解，还是深钻细研、鞭辟入里；你旅游是走马观花、蜻蜓点水，还是下马看花、深度体验；你交友是四海之内皆兄弟，还是人生得一知己足矣……其实都无对错之分，只视不同人的理解而有了不同的诠释。我个人觉得深度和广度是既矛盾又统一的两个方面，偏颇都不可取，还望大家自己慢慢体会。

### **最小生成树**

假设你是电信的实施工程师，需要为一个镇的九个村庄架设通信网络做设计，村庄位置大致如图7-6-1，其中v0～v8是村庄，之间连线的数字表示村与村间的可通达的直线距离，比如v0至v1就是10公里（个别如v0与v6，v6与v8，v5与v7未测算距离是因为有高山或湖泊，不予考虑）。你们领导要求你必须用最小的成本完成这次任务。你说怎么办？显然这是一个带权值的图，即网结构。所谓的最小成本，就是n个顶点，用n-1条边把一个连通图连接起来，并且使得权值的和最小。在这个例子里，每多一公里就多一份成本，所以只要让线路连线的公里数最少，就是最少成本了。

我们在讲图的定义和术语时，曾经提到过，一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。显然图7-6-2的三个方案都是图7-6-1的网图的生成树。那么我们把构造连通网的最小代价生成树称为最小生成树（Minimum Cost SpanningTree）。

找连通网的最小生成树，经典的有两种算法，普里姆算法和克鲁斯卡尔算法。我们就分别来介绍一下。

#### **普里姆（Prim）算法**

为了能讲明白这个算法，我们先构造邻接矩阵。

![2022-08-03 20-52-25屏幕截图](/home/cccmmf/ccode/dhsjjg/screenshot/2022-08-03 20-52-25屏幕截图.png)

现在我们已经有了一个存储结构为MGragh的G。G有9个顶点，它的arc二维数组如图所示。数组中的我们用65535来代表∞。

于是普里姆（Prim）算法代码如下，左侧数字为行号。其中INFINITY为权值极大值，不妨是65535，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Prim函数，输入上述的邻接矩阵后，看看它是如何运行并打印出最小生成树的。

```c
/* Prim算法生成最小生成树 */
  void MiniSpanTree_Prim(MGraph G)
  {
      int min, i, j, k;
      /* 保存相关顶点下标 */
      int adjvex[MAXVEX];                        
      /* 保存相关顶点间边的权值 */
      int lowcost[MAXVEX];                       
      /* 初始化第一个权值为0，即v0加入生成树 */
      /* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */
      lowcost[0] = 0;                            
      /* 初始化第一个顶点下标为0 */
      adjvex[0] = 0;                             
      /* 循环除下标为0外的全部顶点 */
      for (i = 1; i < G.numVertexes; i++)        
      {
         /* 将v0顶点与之有边的权值存入数组 */
         lowcost[i] = G.arc[0][i];              
         /* 初始化都为v0的下标 */
         adjvex[i] = 0;                         
     }
     for (i = 1; i < G.numVertexes; i++)
     {
         /* 初始化最小权值为∞， */
         /* 通常设置为不可能的大数字如32767、65535等 */
         min = INFINITY; //了之后找到一定范围内的最小权值。                       
         j = 1; k = 0; //j是用来做顶点下标循环的变量，k是用来存储最小权值的顶点下标。
         /* 循环全部顶点 */
         while (j < G.numVertexes)              
         {
             /* 如果权值不为0且权值小于min */
             if (lowcost[j] != 0 && lowcost[j] < min)
             {                                  
                 /* 则让当前权值成为最小值 */
                 min = lowcost[j];              
                 /* 将当前最小值的下标存入k */
                 k = j;                         
             }
             j++;
         }
         /* 打印当前顶点边中权值最小边 */
         printf("(%d,%d)", adjvex[k], k);       
         /* 将当前顶点的权值设置为0，表示此顶点已经完成任务 */
         lowcost[k] = 0;                        
         /* 循环所有顶点 */
         for (j = 1; j < G.numVertexes; j++)    
         {
             /* 若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */
             if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j])
             {                                  
                 /* 将较小权值存入lowcost */
                 lowcost[j] = G.arc[k][j];      
                 /* 将下标为k的顶点存入adjvex */
                 adjvex[j] = k;                 
             }
         }
     }
 }
```

1．程序开始运行，我们由第4～5行，创建了两个一维数组lowcost和adjvex，长度都为顶点个数9。它们的作用我们慢慢细说。

2．第6～7行我们分别给这两个数组的第一个下标位赋值为0，adjvex[0]=0其实意思就是我们现在从顶点v0开始（事实上，最小生成树从哪个顶点开始计算都无所谓，我们假定从v0开始），lowcost[0]=0就表示v0已经被纳入到最小生成树中，之后凡是lowcost数组中的值被设置为0就是表示此下标的顶点被纳入最小生成树。

3．第8～12行表示我们读取邻接矩阵的第一行数据。将数值赋值给lowcost数组，所以此时lowcost数组值为{0,10,65535,65535,65535,11,65535,65535,65535}，而adjvex则全部为0。此时，我们已经完成了整个初始化的工作，准备开始生成。

4．第13～36行，整个循环过程就是构造最小生成树的过程。

5．第15～16行，将min设置为了一个极大值65535，它的目的是为了之后找到一定范围内的最小权值。j是用来做顶点下标循环的变量，k是用来存储最小权值的顶点下标。

6．第17～25行，循环中不断修改min为当前lowcost数组中最小值，并用k保留此最小值的顶点下标。经过循环后，min=10，k=1。注意19行if判断的lowcost[j]!=0表示已经是生成树的顶点不参与最小权值的查找。

7．第26行，因k=1，adjvex[1]=0，所以打印结果为(0,1)，表示v0至v1边为最小生成树的第一条边。

8．第27行，此时因k=1我们将lowcost[k]=0就是说顶点v1纳入到最小生成树中。此时lowcost数组值为{0,0,65535,65535,65535,11,65535,65535,65535}。

9．第28～35行，j循环由1至8，因k=1，查找邻接矩阵的第v1行的各个权值，与low-cost的对应值比较，若更小则修改low-cost值，并将k值存入adjvex数组中。因第v1行有18、16、12均比65535小，所以最终lowcost数组的值为：{0,0,18,65535,65535,11,16,65535,12}。adjvex数组的值为：{0,0,1,0,0,0,1,0,1}。这里第30行if判断的lowcost[j]!=0也说明v0和v1已经是生成树的顶点不参与最小权值的比对了。10．再次循环，由第15行到第26行，此时min=11，k=5，adjvex[5]=0。因此打印结构为(0,5)。表示v0至v5边为最小生成树的第二条边。

11．接下来执行到36行，lowcost数组的值为：{0,0,18,65535,26,0,16,65535,12}。ad-jvex数组的值为：{0,0,1,0,5,0,1,0,1}。12．之后，相信大家也都会自己去模拟了。

假设N=(V,{E})是连通网，TE是N上最小生成树中边的集合。算法从U={u0}(u0∈V)，TE={}开始。重复执行下述操作：在所有u∈U,v∈V-U的边(u,v)∈E中找一条代价最小的边(u0,v0)并入集合TE，同时v0并入U，直至U=V为止。此时TE中必有n-1条边，则T=(V,{TE})为N的最小生成树。由算法代码中的循环嵌套可得知此算法的时间复杂度为O(n2)。

#### **克鲁斯卡尔（Kruskal）算法**

现在我们来换一种思考方式，普里姆（Prim）算法是以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树的。这就像是我们如果去参观某个展会，例如世博会，你从一个入口进去，然后找你所在位置周边的场馆中你最感兴趣的场馆观光，看完后再用同样的办法看下一个。可我们为什么不事先计划好，进园后直接到你最想去的场馆观看呢？事实上，去世博园的观众，绝大多数都是这样做的。

同样的思路，我们也可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。此时我们就用到了图的存储结构中的边集数组结构。

```c
/* 对边集数组Edge结构的定义 */
typedef struct
{
    int begin;
    int end;
    int weight;
} Edge;
```

我们将邻接矩阵通过程序转化为边集数组，并且对它们按权值从小到大排序。

![2022-08-03 21-43-18屏幕截图](/home/cccmmf/ccode/dhsjjg/screenshot/2022-08-03 21-43-18屏幕截图.png)

克鲁斯卡尔（Kruskal）算法代码如下，左侧数字为行号。其中MAXEDGE为边数量的极大值，此处大于等于15即可，MAXVEX为顶点个数最大值，此处大于等于9即可。现在假设我们自己就是计算机，在调用MiniSpanTree_Kruskal函数，输入图7-6-3右图的邻接矩阵后，看看它是如何运行并打印出最小生成树的。

```c
/* Kruskal算法生成最小生成树 */
/* 生成最小生成树 */
void MiniSpanTree_Kruskal(MGraph G)     
{
    int i, n, m;
    /* 定义边集数组 */
    Edge edges[MAXEDGE];                
    /* 定义一数组用来判断边与边是否形成环路 */
    int parent[MAXVEX];                 
    /* 此处省略将邻接矩阵G转化为边集数组edges
       并按权由小到大排序的代码 */
    for (i = 0; i < G.numVertexes; i++)
        /* 初始化数组值为0 */
        parent[i] = 0;                  
    /* 循环每一条边 */
    for (i = 0; i < G.numEdges; i++)    
    {
       n = Find(parent, edges[i].begin);
       m = Find(parent, edges[i].end);
       /* 假如n与m不等，说明此边没有与现有生成树形成环路 */
       if (n != m)                     
       {
           /* 将此边的结尾顶点放入下标为起点的parent中 */
           /* 表示此顶点已经在生成树集合中 */
           parent[n] = m;              
           printf("(%d, %d) %d ", edges[i].begin, 
                  edges[i].end, edges[i].weight);
       }
    }
}
/* 查找连线顶点的尾部下标 */
int Find(int *parent, int f)            
{
    while (parent[f] > 0)
        f = parent[f];
    return f;
}
```

1．程序开始运行，第5行之后，我们省略掉颇占篇幅但却很容易实现的将邻接矩阵转换为边集数组，并按权值从小到大排序的代码，也就是说，在第5行开始，我们已经有了结构为edge，数据内容是图7-6-7的右图的一维数组edges。

2．第5～7行，我们声明一个数组parent，并将它的值都初始化为0，它的作用我们后面慢慢说。

3．第8～17行，我们开始对边集数组做循环遍历，开始时，i=0。

4．第10行，我们调用了第19～25行的函数Find，传入的参数是数组parent和当前权值最小边(v4,v7)的begin:4。因为parent中全都是0所以传出值使得n=4。

5．第11行，同样作法，传入(v4,v7)的end:7。传出值使得m=7。

6．第12～16行，很显然n与m不相等，因此parent[4]=7。此时parent数组值为{0,0,0,0,7,0,0,0,0}，并且打印得到“(4,7)7”。此时我们已经将边(v4,v7)纳入到最小生成树中。

7．循环返回，执行10～16行，此时i=1，edge[1]得到边(v2,v8)，n=2，m=8，par-ent[2]=8，打印结果为“(2,8)8”，此时parent数组值为{0,0,8,0,7,0,0,0,0}，这也就表示边(v4,v7)和边(v2,v8)已经纳入到最小生成树。

8．再次执行10～16行，此时i=2，edge[2]得到边(v0,v1)，n=0，m=1，parent[0]=1，打印结果为“(0,1)10”，此时parent数组值为{1,0,8,0,7,0,0,0,0}，此时边(v4,v7)、(v2,v8)和(v0,v1)已经纳入到最小生成树。

9．当i=3、4、5、6时，分别将边(v0,v5)、(v1,v8)、(v3,v7)、(v1,v6)纳入到最小生成树中。此时parent数组值为{1,5,8,7,7,8,0,0,6}，怎么去解读这个数组现在这些数字的意义呢？

![2022-08-03 21-53-43屏幕截图](/home/cccmmf/ccode/dhsjjg/screenshot/2022-08-03 21-53-43屏幕截图.png)

图i=6的粗线连线可以得到，我们其实是有两个连通的边集合A与B中纳入到最小生成树中的，如图7-6-12所示。当parent[0]=1，表示v0和v1已经在生成树的边集合A中。此时将parent[0]=1的1改为下标，由par-ent[1]=5，表示v1和v5在边集合A中，par-ent[5]=8表示v5与v8在边集合A中，par-ent[8]=6表示v8与v6在边集合A中，par-ent[6]=0表示集合A暂时到头，此时边集合A有v0、v1、v5、v8、v6。我们查看parent中没有查看的值，parent[2]=8表示v2与v8在一个集合中，因此v2也在边集合A中。再由parent[3]=7、par-ent[4]=7和parent[7]=0可知v3、v4、v7在另一个边集合B中。

假设N=(V,{E})是连通网，则令最小生成树的初始状态为只有n个顶点而无边的非连通图T={V,{}}，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。

此算法的Find函数由边数e决定，时间复杂度为O(loge)，而外面有一个for循环e次。所以克鲁斯卡尔算法的时间复杂度为O(eloge)。

对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。

### **最短路径**

在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。显然，我们研究网图更有实际意义，就地图来说，距离就是两顶点间的权值之和。而非网图完全可以理解为所有的边的权值都为1的网。

来讲第一种，从某个源点到其余各顶点的最短路径问题。

![2022-08-04 09-16-13屏幕截图](/home/cccmmf/ccode/dhsjjg/screenshot/2022-08-04 09-16-13屏幕截图.png)

#### **迪杰斯特拉（Dijkstra）算法**

这是一个按路径长度递增的次序产生最短路径的算法。它的思路大体是这样的。比如说要求图7-7-3中顶点v0到顶点v1的最短距离，没有比这更简单的了，答案就是1，路径就是直接v0连线到v1。

由于顶点v1还与v2、v3、v4连线，所以此时我们同时求得了v0→v1→v2=1+3=4，v0→v1→ v3=1+7=8，v0→v1→v4=1+5=6。现在，我问v0到v2的最短距离，如果你不假思索地说是5，那就犯错了。因为边上都有权值，刚才已经有v0→v1→v2的结果是4，比5还要小1个单位，它才是最短距离。

由于顶点v2还与v4、v5连线，所以此时我们同时求得了v0→v2→v4其实就是v0→v1→v2→v4=4+1=5，v0→v2→v5=4+7=11。这里v0→v2我们用的是刚才计算出来的较小的4。此时我们也发现v0→v1→v2→v4=5要比v0→v1→v4=6还要小。所以v0到v4目前的最小距离是5。

由于顶点v2还与v4、v5连线，所以此时我们同时求得了v0→v2→v4其实就是v0→v1→v2→v4=4+1=5，v0→v2→v5=4+7=11。这里v0→v2我们用的是刚才计算出来的较小的4。此时我们也发现v0→v1→v2→v4=5要比v0→v1→v4=6还要小。所以v0到v4目前的最小距离是5。

当我们要求v0到v3的最短距离时，通向v3的三条边，除了v6没有研究过外，v0→v1→v3的结果是8，而v0→v4→v3=5+2=7。因此，v0到v3的最短距离是7。

```c
#define MAXVEX 9
#define INFINITY 65535
typedef int 
/* 用于存储最短路径下标的数组 */
Patharc[MAXVEX];                       
typedef int 
/* 用于存储到各点最短路径的权值和 */
ShortPathTable[MAXVEX];                
/* Dijkstra算法，求有向网G的v0顶点到其余顶点v最短路径P[v]及带权长度D[v] */
/* P[v]的值为前驱顶点下标，D[v]表示v0到v的最短路径长度和。 */
void ShortestPath_Dijkstra(MGraph G, int v0, 
                           Patharc *P, ShortPathTable *D)
{
    int v, w, k, min;
    /* final[w]=1表示求得顶点v0至vw的最短路径 */
    int final[MAXVEX];                          
    /* 初始化数据 */
    for (v = 0; v < G.numVertexes; v++)         
    {
        /* 全部顶点初始化为未知最短路径状态 */
        final[v] = 0;                           
        /* 将与v0点有连线的顶点加上权值 */
        (*D)[v] = G.arc[v0][v];                 
        /* 初始化路径数组P为-1 */
        (*P)[v] = -1;                           
    }
    /* v0至v0路径为0 */
    (*D)[v0] = 0;                               
    /* v0至v0不需要求路径 */
    final[v0] = 1;                              
    /* 开始主循环，每次求得v0到某个v顶点的最短路径 */
    for (v = 1; v < G.numVertexes; v++)
    {
        /* 当前所知离v0顶点的最近距离 */
        min=INFINITY;                           
        /* 寻找离v0最近的顶点 */
        for (w = 0; w < G.numVertexes; w++)     
         {
            if (!final[w] && (*D)[w] < min)
            {
                k=w;
                /* w顶点离v0顶点更近 */
                min = (*D)[w];                  
            }
        }
        /* 将目前找到的最近的顶点置为1 */
        final[k] = 1;                           
        /* 修正当前最短路径及距离 */
        for (w = 0; w < G.numVertexes; w++)     
        {   
            /* 如果经过v顶点的路径比现在这条路径的长度短的话 */
            if (!final[w] && (min + G.arc[k][w] < (*D)[w]))
            {                                   
                /* 说明找到了更短的路径，修改D[w]和P[w] */
                /* 修改当前路径长度 */
                (*D)[w] = min + G.arc[k][w];    
                (*P)[w]=k;
            }
        }
    }
}
```

![2022-08-04 09-29-40屏幕截图](/home/cccmmf/ccode/dhsjjg/screenshot/2022-08-04 09-29-40屏幕截图.png)

1．程序开始运行，第4行final数组是为了v0到某顶点是否已经求得最短路径的标记，如果v0到vw已经有结果，则fi-nal[w]=1。

2．第5～10行，是在对数据进行初始化的工作。此时final数组值均为0，表示所有的点都未求得最短路径。D数组为{65535,1,5,65535,65535,65535,65535,65535,65535}。因为v0与v1和v2的边权值为1和5。P数组全为0，表示目前没有路径。

3．第11行，表示v0到v0自身，权值和结果为0。D数组为{0,1,5,65535,65535,65535,65535,65535,65535}。第12行，表示v0点算是已经求得最短路径，因此final[0]=1。此时final数组为{1,0,0,0,0,0,0,0,0}。此时整个初始化工作完成。

4．第13～33行，为主循环，每次循环求得v0与一个顶点的最短路径。因此v从1而不是0开始。

5．第15～23行，先令min为65535的极大值，通过w循环，与D[w]比较找到最小值min=1，k=1。

6．第24行，由k=1，表示与v0最近的顶点是v1，并且由D[1]=1，知道此时v0到v1的最短距离是1。因此将v1对应的final[1]设置为1。此时final数组为{1,1,0,0,0,0,0,0,0}。

7．第25～32行是一循环，此循环甚为关键。它的目的是在刚才已经找到v0与v1的最短路径的基础上，对v1与其他顶点的边进行计算，得到v0与它们的当前最短距离，如图7-7-8所示。因为min=1，所以本来D[2]=5，现在v0→v1→v2=D[2]=min+3=4，v0→v1→v3=D[3]=min+7=8，v0→v1→v4=D[4]=min+5=6，因此，D数组当前值为{0,1,4,8,6,65535,65535,65535,65535}。而P[2]=1，P[3]=1，P[4]=1，它表示的意思是v0到v2、v3、v4点的最短路径它们的前驱均是v1。此时P数组值为：{0,0,1,1,1,0,0,0,0}。

8．重新开始循环，此时v=2。第15～23行，对w循环，注意因为final[0]=1和final[1]=1，由第18行的!final[w]可知，v0与v1并不参与最小值的获取。通过循环比较，找到最小值min=4，k=2。

9．第24行，由k=2，表示已经求出v0到v2的最短路径，并且由D[2]=4，知道最短距离是4。因此将v2对应的final[2]设置为1，此时final数组为：{1,1,1,0,0,0,0,0,0}。

10．第25～32行。在刚才已经找到v0与v2的最短路径的基础上，对v2与其他顶点的边，进行计算，得到v0与它们的当前最短距离，如图7-7-9所示。因为min=4，所以本来D[4]=6，现在v0→v2→v4=D[4]=min+1=5，v0→v2→v5=D[5]=min+7=11，因此，D数组当前值为：{0,1,4,8,5,11,65535,65535,65535}。而原本P[4]=1，此时P[4]=2，P[5]=2，它表示v0到v4、v5点的最短路径它们的前驱均是v2。此时P数组值为：{0,0,1,1,2,2,0,0,0}。

11．重新开始循环，此时v=3。第15～23行，通过对w循环比较找到最小值min=5，k=4。

12．第24行，由k=4，表示已经求出v0到v4的最短路径，并且由D[4]=5，知道最短距离是5。因此将v4对应的final[4]设置为1。此时final数组为：{1,1,1,0,1,0,0,0,0}。

13．第25～32行。对v4与其他顶点的边进行计算，得到v0与它们的当前最短距离，如图7-7-10所示。因为min=5，所以本来D[3]=8，现在v0→v4→v3=D[3]=min+2=7，本来D[5]=11，现在v0→v4→v5=D[5]=min+3=8，另外v0→v4→v6=D[6]=min+6=11，v0→v4→v7=D[7]=min+9=14，因此，D数组当前值为：{0,1,4,7,5,8,11,14,65535}。而原本P[3]=1，此时P[3]=4，原本P[5]=2，此时P[5]=4，另外P[6]=4，P[7]=4，它表示v0到v3、v5、v6、v7点的最短路径它们的前驱均是v4。此时P数组值为：{0,0,1,4,2,4,4,4,0}。

14．之后的循环就完全类似了。得到最终的结果，如图7-7-11所示。此时final数组为：{1,1,1,1,1,1,1,1,1}，它表示所有的顶点均完成了最短路径的查找工作。此时D数组为：{0,1,4,7,5,8,10,12,16}，它表示v0到各个顶点的最短路径数，比如D[8]=1+3+1+2+3+2+4=16。此时的P数组为：{0,0,1,4,2,4,3,6,7}，这串数字可能略为难理解一些。比如P[8]=7，它的意思是v0到v8的最短路径，顶点v8的前驱顶点是v7，再由P[7]=6表示v7的前驱是v6，P[6]=3，表示v6的前驱是v3。这样就可以得到，v0到v8的最短路径为v8←v7←v6←v3←v4←v2←v1←v0，即v0→v1→v2→v4→v3→v6→v7→v8。

其实最终返回的数组D和数组P，是可以得到v0到任意一个顶点的最短路径和路径长度的。例如v0到v8的最短路径并没有经过v5，但我们已经知道v0到v5的最短路径了。由D[5]=8可知它的路径长度为8，由P[5]=4可知v5的前驱顶点是v4，所以v0到v5的最短路径是v0→v1→v2→v4→v5。

也就是说，我们通过迪杰斯特拉（Dijkstra）算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为O(n2)，尽管有同学觉得，可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有顶点的最短路径一样复杂，时间复杂度依然是O(n2)。

可如果我们还需要知道如v3到v5、v1到v7这样的任一顶点到其余所有顶点的最短路径怎么办呢？此时简单的办法就是对每个顶点当作源点运行一次迪杰斯特拉（Dijkstra）算法，等于在原有算法的基础上，再来一次循环，此时整个算法的时间复杂度就成了O(n3)。对此，我们现在再来介绍另一个求最短路径的算法——弗洛伊德（Floyd），它求所有顶点到所有顶点的时间复杂度也是O(n3)，但其算法非常简洁优雅，能让人感觉到智慧的无限魅力。

#### **弗洛伊德（Floyd）算法**







