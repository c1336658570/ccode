/*
连续整数求和
你一个整数n，你需要找到两个整数l和r，它们的范围是： -10^{18} <l < r < 10^{18}
并且使得 l + (l + 1) +... + (r - 1) + r = n

Input
第一行输入一个单独的整数 t (1 <= t <= 10^4) 表示测试用例的组数。

每组测试用例只有一行，每行只有一个整数 n(1 <= n <= 10^{18}).

Output
对于每组测试用例，输出两个整数 l 和 r ，令l + (l + 1) +... + (r - 1) + r = n
且-10^{18} <l < r < 10^{18}

可以证明答案一定存在，如果有多种不同的答案，只需输出其中任意一种即可。
Example
Input
7
1
2
3
6
100
25
3000000000000
Output
0 1
-1 2 
1 2 
1 3 
18 22
-2 7
999999999999 1000000000001
Note
对于第一组测试用例：0 + 1 = 1.
对于第二组测试用例：(-1) + 0 + 1 + 2 = 2.
对于第四组测试用例：1 + 2 + 3 = 6.
对于第五组测试用例：18 + 19 + 20 + 21 + 22 = 100.
对于第六组测试用例：(-2) + (-1) + 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 = 25.
*/

# include <stdio.h>

int main(void)
{
    long long n, i, j, k, l, r;
    scanf("%lld", &n);
    long long val;
    for (i = 0; i < n; ++i)
    {
        scanf("%lld", &val);
        if (val % 2 == 1)
        {
            l = val/2;
            r = val/2+1;
        }
        else
        {
            l = 1-val;
            r = val;
        }
        printf("%lld %lld\n", l, r);
    }
    
    //超时
    /*
    for (i = 0; i < n; ++i)
    {
        l = 0;
        r = 0;
        while ((l+r)*(r-l+1)/2 != a[i])
        {
            if ((l+r)*(r-l+1)/2 < a[i])
                r++;
            else if((l+r)*(r-l+1)/2 > a[i])
                l--;
            else
                break;
        }
        printf("%ld %ld\n", l, r);
    }
    */

    return 0;
}
